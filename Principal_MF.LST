C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PRINCIPAL_MF
OBJECT MODULE PLACED IN .\hex\Principal_MF.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Principal_MF.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)
                    - OBJECT(.\hex\Principal_MF.obj)

line level    source

   1          //*******************************************************************************************
   2          //  usa LPR, envia wiegand al secundario
   3          //  Solo funciona con Hardware v4
   4          //
   5          //*******************************************************************************************
   6          #include <P89V51Rx2.h>              // define 8051 registers                *
   7          #include <stdio.h>          //                            *
   8          #include <INTRINS.H>        //                            *
   9          #include <math.h>                   //                            *          
  10          #include "display.h"        //                            *
  11          //#include "wiegand.h"
  12          //*******************************************************************************************
  13          //  DEFINICION DE IO DEL MICROCONTROLADOR                         *
  14          //*******************************************************************************************
  15          sbit msg1  = P0^0;          //Relevo de Salida (AUDIO)                *
  16          sbit msg2  = P0^1;          //Relevo de Salida (AUDIO)                *
  17          sbit msg3  = P0^2;          //Relevo de Salida (AUDIO)                *
  18          sbit msg4  = P0^3;          //Relevo de Salida (AUDIO)                *
  19          
  20          sbit sw_1 = P1^2;         //Direccion                       *
  21          sbit sw_2 = P1^3;         //Direccion                       *
  22          sbit ledv = P1^4;         //Led del boton expedidor               *
  23          sbit lock1  = P1^6;         //Relevo de Entrada                   *
  24          sbit lock2  = P1^5;         //Relevo de Salida (Inhabilitado Proc. Aux usa ERR IMP) *
  25          sbit Electroiman  = P1^7;     //Para Cajon Monedero                 *
  26          //sbit automovil  = P1^7;     //Entrada sensor automovil                *
  27          sbit SignalAcceso = P3^7;     //Sigue la señal de Sensor                *
  28          sbit busy=P3^5;             //                            *
  29          sbit ready=P3^4;          //                            *
  30          sbit bus_clk=P3^6;          //                            *
  31          //*******************************************************************************************
  32          // unsigned char expedidor    []= " AccesScan v0.2 " ;
  33          
  34           unsigned char offlinea     []= "EN MANTENIMIENTO" ;
  35           unsigned char err_mifare   []= "TARJETA INVALIDA" ;
  36           unsigned char err_cod      []= "ERROR COD. PARQ." ;
  37           unsigned char err_in       []= "  SIN INGRESO   " ;
  38          // unsigned char err_tipo     []= "STATUS NO VALIDO" ;
  39           unsigned char err_alarma   []= "ALARMA    ACTIVA" ;
  40          
  41           unsigned char linea        []= "CAJERO OPERATIVO" ;
  42          // unsigned char err_uso      []= "LO SENTIMOS....." ;
  43          
  44           unsigned char CMD_Out      []= "CMD EXPULSION..." ;
  45           unsigned char OutWR        []= "TARJETA GRABADA." ;
  46           unsigned char OutSEL       []= "ERROR SEL. CARD " ;
  47           unsigned char ingreso      []= "In:             " ;
  48           unsigned char FueraServ    []= "  SIN SERVICIO  " ;
  49           unsigned char err_wr     []= "ERROR GRABACION " ;
  50           unsigned char err_lect     []= "ERROR RTA LECTOR" ;
  51          // unsigned char err_Tarjeta  []= " ERROR TARJETA  " ;
  52          // unsigned char err_TIME   []= " ERROR TIME OUT SW" ;
  53           unsigned char NIVEL;
  54           unsigned char Time_Devolucion=0;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 2   

  55          //*******************************************************************************************   
  56          //    DEFINICIÓN DE TIPOS
  57          //*******************************************************************************************
  58          // typedef enum {false=0, true=1} boolean;
  59          //*******************************************************************************************
  60           unsigned int contador;         //contador de proposito general           *
  61          
  62          // unsigned char cte_seg;           //Constante para segundo
  63           unsigned char byte;
  64          // unsigned char apunta=0;
  65          
  66           unsigned char num_bytes;
  67          // unsigned char control;
  68          // unsigned char dir_h;
  69          // unsigned char dir_l;
  70          // unsigned char Print_Model;
  71          
  72           unsigned char Estado_Luz;
  73           unsigned char byte_out;
  74          
  75          // unsigned char fc;
  76          // unsigned char cod_h;
  77          // unsigned char cod_l;
  78          
  79           unsigned char chr;
  80           unsigned char num_data;
  81           unsigned char len_buffer;
  82          
  83           unsigned char seg2;
  84           unsigned char seg;
  85          
  86           unsigned char xdata buffer_rx[60];     //Buffer de recepcion de comunicacion
  87           unsigned char xdata buffer_ticket[60];
  88          // unsigned char xdata buffer_wie[5];
  89           unsigned char xdata buffer_bus[60];
  90          
  91          
  92           unsigned char num_datos;
  93          
  94           unsigned int TimeOut_Codigo;
  95          
  96          
  97          // unsigned char baud_rate;
  98           unsigned char val_time_bit;
  99           unsigned char temp; 
 100           unsigned char TimeOutLinea;
 101           unsigned char g_cRelevos;
 102          
 103          
 104          
 105          
 106          // char nbitsW;
 107          // unsigned long int byte_wie=0x00000000;
 108          
 109           bit time_out;
 110           bit time_out_com;
 111           bit error_com;
 112           bit flag_segundo;            //Bandera de segundo
 113           bit txACK;
 114           bit txEOT;
 115          // bit inicio_impresion;
 116          // bit release;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 3   

 117           
 118          // bit cmd_esc;
 119          // bit rx_serie;
 120          // bit err_print;
 121          // bit CoverPrint;
 122          // bit PaperOut;
 123          // bit Transport;
 124          // bit JamPaper;
 125          // bit bandera_rx_soft;
 126          // bit flanco_wiegand;
 127          
 128           bit toogle;
 129           bit FueraLinea=0;
 130          // bit inicio_wiegand;
 131           bit retry;
 132          // bit Flag_Dcto=0;
 133           bit txRTA=0;
 134           FueraServicio=0;
 135          // unsigned char msg_error;
 136           unsigned char temp;
 137           bit sendactive=0;
 138          
 139           bit audio1=0;
 140           bit audio2=0;                
 141           bit audio3=0;
 142           bit audio4=0;
 143          
 144           bit Grabacion=0;
 145           bit Rta_Send=0;
 146          //--------------------------------------------------------------------------------------------------*
 147          #define TAMANO_RX_COM_SOFT  100 
 148          #define TAMANO_TX_COM_SOFT  50
 149          #define CICLO_UTIL_BUZZER_SEQ 100
 150          //--------------------------------------------------------------------------------------------------*
 151          //#define VERIFICADOR   0X00
 152          //#define EXPEDIDOR   0X01
 153          //#define CAJA      0X02
 154          
 155          #define cte_seg     0X1c
 156          #define TIMEW     0x1e   //Tiempo para indicar TimeOut
 157          
 158          
 159          //ESTADOR RECEPCION SOFTWARE
 160          #define ESPERA_RX       20
 161          #define VER_DIR         21
 162          #define VER_COMANDO       22
 163          #define LONG          23
 164          #define SAVE_STR_SOF      24
 165          
 166          #define SIN_CMD         25
 167          #define POLL_COM_SOF      26
 168          #define EJECT         27
 169          #define APERTURA        28
 170          #define WR_CLK          29
 171          #define WR_SECTORMF       30
 172          #define WIEGAND         31
 173          #define WR_DISPLAY        32
 174          #define STANDBY         33
 175          #define EJECT_WR        34
 176          #define EXIT          35
 177          #define USUARIOT        36
 178          #define CANCELO         37
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 4   

 179          #define FUERASERV       38
 180          #define EJECT_WR2       39
 181          //ESTADOR TRANSMICION SOFTWARE
 182          
 183          #define SIN_LECTURA_TX    0x00
 184          #define LECTURA_COD_TX    0x01
 185          #define LECTURA_WIEG_TX   0x02
 186          #define APERTURA_PUERTA   0x04
 187          #define RETIRO_COFRE_COIN 0x08
 188          #define RETIRO_COFRE_B2B  0x10  
 189          #define ERROR_INFO      0x20
 190          #define CONSULTA_LECTOR   0x40
 191          #define ERROR_WR_CARD   0x80
 192          #define ERROR_TIME_OUT    0x41
 193          
 194          
 195          #define ENQ 5
 196          #define EOT 4
 197          #define ACK 6
 198          #define STX 2
 199          #define ETX 3
 200          
 201          #define NACK  0X15
 202          
 203          #define CR  0x0d
 204          #define LF  0x0a
 205          //--------------------------------------------------------------------------------------------------*
 206          unsigned char g_cEstadoComSoft=ESPERA_RX;
 207          unsigned char g_cCMD_Soft=SIN_CMD;
 208          unsigned char g_cEstadoTxSoft=SIN_LECTURA_TX;
 209          unsigned char g_cContByteTx=0;
 210          unsigned char g_scArrRxComSoft[TAMANO_RX_COM_SOFT];
 211          unsigned char g_scArrTxComSoft[TAMANO_TX_COM_SOFT];
 212          unsigned char g_cContByteRx=0;
 213          unsigned char g_cDirBoard=0x30;
 214          //unsigned char g_cFlagTipoControl=EXPEDIDOR;   ///CAJA;
 215          unsigned char g_cTimerRxPrinBar=0;
 216          
 217          //int  g_iContBuzzer;
 218          
 219          //--------------------------------------------------------------------------------------------------*
 220          //********************************************************************************************************
             -****
 221          //
 222          //********************************************************************************************************
             -****
 223          
 224          
 225          //********************************************************************************************************
             -****
 226          //********************************************************************************************
 227          bit  tx_bus (unsigned char num_chr)
 228          {
 229   1          unsigned char j, timeOut;
 230   1        long int cont;
 231   1        bit Envio=0;
 232   1      
 233   1        bus_clk=1;
 234   1        cont=30000;
 235   1        timeOut=0;
 236   1        busy=0;
 237   1      //----------------------------------------
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 5   

 238   1        while ((ready==1)&&(timeOut==0))
 239   1        {
 240   2          cont--;
 241   2          if (cont==0)
 242   2          {
 243   3            timeOut=1;
 244   3          }
 245   2        }
 246   1      //---------------------------------------
 247   1          if (timeOut==0)
 248   1        {
 249   2          for (j=0; j<num_chr; j++)
 250   2          {
 251   3              P2=buffer_bus[j];
 252   3            bus_clk=0;
 253   3            wait_long();
 254   3            bus_clk=1;
 255   3            wait_long();
 256   3          }
 257   2          Envio=1;
 258   2        }
 259   1      
 260   1        
 261   1        bus_clk=1;
 262   1        ready=1;
 263   1        busy=1;
 264   1      
 265   1        return Envio;
 266   1      
 267   1      }
 268          
 269          //********************************************************************************************
 270          //*******************************************************************************************
 271          //
 272          // Serial Interrupt Service Routine
 273          //
 274          //*******************************************************************************************
 275          static void com_isr (void) interrupt 4 using 1 
 276          {
 277   1        char cDatoRx;
 278   1      //------------------------------------------------------------------------------------------*
 279   1      // Received data interrupt.                                 *
 280   1      //------------------------------------------------------------------------------------------*
 281   1        if (RI) 
 282   1        {
 283   2            cDatoRx = SBUF;                     // read character
 284   2            RI = 0;                   // clear interrupt request flag
 285   2      
 286   2          switch (g_cEstadoComSoft)
 287   2          {
 288   3      //---------------------------------------------------------------------------------------
 289   3            case ESPERA_RX:
 290   3            
 291   3            g_cContByteRx=0;
 292   3            if(cDatoRx==STX)
 293   3            {
 294   4              g_scArrRxComSoft[g_cContByteRx++]=cDatoRx;
 295   4              g_cEstadoComSoft=VER_DIR;
 296   4            }
 297   3            else  if(cDatoRx==ACK)
 298   3            {
 299   4                //Notifica al secundario que hubo Lectura o SW
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 6   

 300   4                  
 301   4                buffer_bus[0]=ACK;
 302   4                tx_bus(0x01);
 303   4      
 304   4            }
 305   3      
 306   3            break;
 307   3      //--------------------------------------------------------------------------------------
 308   3            case VER_DIR:
 309   3      
 310   3            if(cDatoRx==g_cDirBoard)
 311   3            {
 312   4              g_scArrRxComSoft[g_cContByteRx++]=cDatoRx;
 313   4              g_cEstadoComSoft=LONG;
 314   4            }
 315   3            else
 316   3            {
 317   4              g_cEstadoComSoft=ESPERA_RX;
 318   4            }
 319   3            break;
 320   3      //--------------------------------------------------------------------------------------
 321   3            case LONG:
 322   3      
 323   3            g_scArrRxComSoft[g_cContByteRx++]=cDatoRx;
 324   3            g_cEstadoComSoft=SAVE_STR_SOF;
 325   3      
 326   3            break;
 327   3      //-----------------------------------------------------------------------------------------
 328   3            case SAVE_STR_SOF:
 329   3          
 330   3            g_scArrRxComSoft[g_cContByteRx++]=cDatoRx;
 331   3            if(g_cContByteRx>TAMANO_RX_COM_SOFT)
 332   3            {
 333   4              g_cEstadoComSoft=ESPERA_RX;
 334   4            }
 335   3            else if(cDatoRx==ETX)
 336   3            {
 337   4              TimeOutLinea=TIMEW;
 338   4              FueraLinea=0;
 339   4      
 340   4              switch (g_scArrRxComSoft[3])
 341   4              {
 342   5                case 'p':
 343   5                  g_cCMD_Soft=POLL_COM_SOF;         // Poll
 344   5                break;
 345   5            
 346   5          
 347   5                case 'A':                     // Apertura
 348   5                  g_cCMD_Soft=APERTURA;
 349   5                break;
 350   5      
 351   5                case 'O':                     // Out Card: Eject
 352   5                
 353   5                  if (g_cContByteRx==16)
 354   5                  {
 355   6                    Grabacion=1;
 356   6                    g_cCMD_Soft=EJECT_WR;
 357   6                    Estado_Luz=0x03;
 358   6                    Time_Devolucion=10;
 359   6                  }
 360   5                  else  
 361   5                  {
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 7   

 362   6                    g_cCMD_Soft=EJECT;
 363   6                    if  (Grabacion==0)
 364   6                    {
 365   7                      Estado_Luz=0x01;
 366   7                    }
 367   6                    
 368   6                  }
 369   5                  
 370   5      
 371   5                break;
 372   5      
 373   5      
 374   5                case 's':                     // Out Card: Eject
 375   5                
 376   5                  if (g_cContByteRx==21)
 377   5                  {
 378   6                    Grabacion=1;
 379   6                    g_cCMD_Soft=EJECT_WR2;
 380   6                    Estado_Luz=0x03;
 381   6                    Time_Devolucion=10;
 382   6                  }
 383   5                  else  
 384   5                  {
 385   6                    g_cCMD_Soft=EJECT;
 386   6                    if  (Grabacion==0)
 387   6                    {
 388   7                      Estado_Luz=0x01;
 389   7                    }
 390   6                    
 391   6                  }           
 392   5      
 393   5                break;
 394   5      
 395   5      
 396   5      
 397   5                case 'M':                     // Out Card: Eject
 398   5                  
 399   5                    g_cCMD_Soft=EJECT_WR;
 400   5        
 401   5                break;
 402   5      
 403   5                case 'o':                     // Cancelo Tarjeta T
 404   5      
 405   5                  g_cCMD_Soft=CANCELO;
 406   5                    Estado_Luz=0x01;
 407   5      
 408   5                break;
 409   5      
 410   5                case 'F':                     // Cancelo Tarjeta T
 411   5      
 412   5                  g_cEstadoComSoft=ESPERA_RX;
 413   5                  g_cCMD_Soft=FUERASERV;
 414   5                    FueraServicio=1;
 415   5      
 416   5                break;
 417   5      
 418   5                case 'S':                     // Wiegand
 419   5                  
 420   5                  g_cEstadoComSoft= ESPERA_RX;
 421   5                  if (g_scArrRxComSoft[4]=='1')
 422   5                  {
 423   6                    g_cEstadoTxSoft &=~APERTURA_PUERTA;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 8   

 424   6                  }
 425   5                  else if (g_scArrRxComSoft[4]=='2')
 426   5                  {
 427   6                    g_cEstadoTxSoft &=~RETIRO_COFRE_B2B;
 428   6                  }
 429   5                  else if (g_scArrRxComSoft[4]=='3')
 430   5                  {
 431   6                    g_cEstadoTxSoft &=~RETIRO_COFRE_COIN;
 432   6                  }
 433   5      
 434   5                break;
 435   5      
 436   5                  case 'W':                     // Tarjeta MF WR
 437   5                  g_cCMD_Soft=WR_SECTORMF;
 438   5                break;
 439   5      
 440   5                case 'D':                     // Mensaje Display
 441   5                  g_cCMD_Soft=WR_DISPLAY;
 442   5                  break;
 443   5      
 444   5                case 'w':                     // Wiegand
 445   5                  g_cCMD_Soft=WIEGAND;
 446   5                break;
 447   5      
 448   5                case 'e':                     // Wiegand
 449   5                  g_cEstadoTxSoft &= ~ERROR_INFO;
 450   5                  
 451   5                break;
 452   5      
 453   5                case 'U':                     // Wiegand
 454   5                  g_cEstadoTxSoft &= ~ERROR_INFO;
 455   5                  g_cCMD_Soft=USUARIOT;
 456   5                  NIVEL=g_scArrRxComSoft[4];
 457   5                break;
 458   5                
 459   5      
 460   5                case 'E':                     // Wiegand
 461   5      
 462   5                  Electroiman=1;
 463   5                  FueraServicio=0;
 464   5                  g_cCMD_Soft=EXIT;
 465   5      
 466   5      
 467   5                break;  
 468   5                
 469   5                case '?':                     // Wiegand
 470   5                  
 471   5                  buffer_bus[0]=STX;
 472   5                  buffer_bus[1]=0x30;
 473   5                  buffer_bus[2]=0x05;
 474   5                  buffer_bus[3]='?';
 475   5                  buffer_bus[4]=ETX;
 476   5                  tx_bus(0x05);
 477   5                  buffer_bus[3]=0x00;
 478   5                  g_cEstadoComSoft=ESPERA_RX;
 479   5                  g_cCMD_Soft=SIN_CMD;
 480   5      
 481   5                break;
 482   5      
 483   5      
 484   5      
 485   5                default:
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 9   

 486   5                  buffer_bus[3]=0x00;
 487   5                  g_cEstadoComSoft=ESPERA_RX;
 488   5                  g_cCMD_Soft=SIN_CMD;          
 489   5                break;                            
 490   5              } 
 491   4              g_cEstadoComSoft=ESPERA_RX;
 492   4      
 493   4            }
 494   3            break;
 495   3      //-----------------------------------------------------------------------------------------*
 496   3            default:
 497   3              g_cEstadoComSoft=ESPERA_RX;
 498   3            break;
 499   3          }     
 500   2        }
 501   1      //------------------------------------------------------------------------------------------*
 502   1      // Transmitted data interrupt.                                *
 503   1      //------------------------------------------------------------------------------------------*
 504   1          if (TI != 0) 
 505   1        {
 506   2            TI = 0;                 // clear interrupt request flag
 507   2          sendactive=0;
 508   2          }
 509   1      }
 510          //*******************************************************************************************
 511          //*******************************************************************************************
 512          //  Transmision de un caracter                                *
 513          //*******************************************************************************************
 514           void tx_chr (unsigned char data_com)
 515           {
 516   1        while (sendactive==1) 
 517   1        {
 518   2        }
 519   1          SBUF=data_com;
 520   1        sendactive=1;
 521   1       }
 522          //*******************************************************************************************
 523          void EscribirCadenaSoft(unsigned char tamano_cadena)
 524          {
 525   1      unsigned char i;
 526   1       
 527   1        for(i=0;i<tamano_cadena;i++)
 528   1          {
 529   2              tx_chr(g_scArrTxComSoft[i]);
 530   2          }
 531   1        
 532   1      }
 533          //*******************************************************************************************
 534          //  Transmision de un caracter en 2 nibbles + 30h calcula BCC               *
 535          //*******************************************************************************************
 536          void tx_chrx2 (unsigned char chr)
 537          { 
 538   1        unsigned char temp;
 539   1           
 540   1          temp=chr&(0xf0);
 541   1          temp>>=4;
 542   1          temp=temp|(0x30);
 543   1          tx_chr(temp);
 544   1      
 545   1          temp=chr&(0x0f);
 546   1          temp=temp|(0x30);
 547   1          tx_chr(temp);
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 10  

 548   1      }
 549          
 550          //*******************************************************************************************
 551          //*******************************************************************************************
 552          void relevos_aux(void)
 553          {
 554   1        (audio1==1)?(msg1=1):(msg1=0);
 555   1        (audio2==1)?(msg2=1):(msg2=0);
 556   1        (audio3==1)?(msg3=1):(msg3=0);
 557   1        (audio4==1)?(msg4=1):(msg4=0);
 558   1      }
 559          //*******************************************************************************************
 560          //*******************************************************************************************
 561          //*******************************************************************************************
 562          //  Transmision de 2bytes alamacenados en un entero INT                   *
 563          //*******************************************************************************************
 564          //  Une 2 bytes a entero
 565          //******************************************************************************************
 566          unsigned int concatena (unsigned char byteh, unsigned char byte_l)
 567          {
 568   1        unsigned int valor, valorl;
 569   1      
 570   1          valor=byteh;
 571   1          valor<<=8;
 572   1          valorl=byte_l;
 573   1            valorl=valorl&0x00ff;
 574   1          valor=valor|valorl; 
 575   1          return valor;
 576   1      }
 577          //*******************************************************************************************
 578          //*******************************************************************************************
 579          //  Transmision de 2bytes alamacenados en un entero INT                   *
 580          //*******************************************************************************************
 581           void tx_chr2bytes (unsigned int lchr)
 582           {
 583   1            unsigned int bytelong;
 584   1          unsigned char caracter;
 585   1      
 586   1          bytelong=lchr;
 587   1          bytelong>>=8;
 588   1          caracter=bytelong;
 589   1      //    strobe=1;
 590   1          SBUF=caracter;
 591   1          TI=0;
 592   1          while (TI==0) 
 593   1          {
 594   2       
 595   2          }
 596   1          caracter=lchr&0x00ff;
 597   1          SBUF=caracter;
 598   1          TI=0;
 599   1          while (TI==0) 
 600   1          {
 601   2       
 602   2          }
 603   1      //    strobe=0;
 604   1       }
 605          //********************************************************************************************
 606          
 607          //********************************************************************************************
 608          void rx_bus (void)
 609          {
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 11  

 610   1        long int count;
 611   1        unsigned char timeOut,j=0, MaxData;
 612   1      
 613   1        busy=1;
 614   1        num_data=0;
 615   1        MaxData=60;
 616   1      
 617   1        if (ready==0)
 618   1        {
 619   2          timeOut=0;
 620   2          busy=0;
 621   2          for (j=0; j<MaxData; j++)
 622   2          {                  //50000
 623   3            count=30000;
 624   3            while ((bus_clk==1)&&(ready==0)&&(timeOut==0))
 625   3            {
 626   4              count--;
 627   4              if (count==0)
 628   4              {
 629   5                timeOut=1;
 630   5                j=MaxData+1;
 631   5              }   
 632   4            }  
 633   3            if ((bus_clk==0)&&(timeOut==0)&&(ready==0))
 634   3            {
 635   4              buffer_bus[j]=P2;
 636   4              num_data++; 
 637   4              count=10000;        //65000
 638   4              while ((bus_clk==0)&&(timeOut==0))
 639   4              {
 640   5                buffer_bus[j]=P2;
 641   5                count--;
 642   5                if (count==0)
 643   5                {
 644   6                  timeOut=1;
 645   6                  j=MaxData+1;
 646   6                }       
 647   5              }
 648   4            }
 649   3            if (ready==1)
 650   3            {
 651   4              j=MaxData+1;
 652   4            }
 653   3          }
 654   2          }
 655   1        busy=1;
 656   1        wait_long();
 657   1      }
 658          
 659          //********************************************************************************************
 660          //********************************************************************************************
 661          unsigned char two_one (unsigned char byte_h,unsigned char byte_l)
 662          {
 663   1        byte_h=byte_h&0x0f;
 664   1        byte_h<<=4;
 665   1        byte_l=byte_l&0x0f;
 666   1        byte_out=byte_h|byte_l;
 667   1        return byte_out;
 668   1      }
 669          //*******************************************************************************************
 670          //*******************************************************************************************
 671          //  COVIERTE DE HEXADECIMAL A DECIMAL 2BYTES                        *
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 12  

 672          //*******************************************************************************************
 673          void ve_id(unsigned char xTIPO, unsigned char fc, unsigned char id_h, unsigned char id_l, unsigned char id
             -_l2)
 674          {
 675   1        unsigned long int valor,numero, j;
 676   1        unsigned char buffer_name[16];
 677   1      
 678   1        unsigned char Mmillon;
 679   1        unsigned char cmillon;
 680   1        unsigned char dmillon;
 681   1        unsigned char millon;
 682   1        unsigned char;
 683   1        unsigned char cmil;
 684   1        unsigned char dmil;
 685   1        unsigned char mil;
 686   1        unsigned char centena;
 687   1        unsigned char decena;
 688   1        unsigned char unidad;
 689   1      
 690   1      
 691   1      //--------------------------------------------------------- 
 692   1      //  tx_chr(xTIPO);
 693   1      //  tx_chr(fc);
 694   1      //  tx_chr(id_h);
 695   1      //  tx_chr(id_l);
 696   1      //  tx_chr(id_l2);
 697   1      //---------------------------------------------------------    
 698   1       
 699   1        valor=0x00000000;
 700   1        numero=0x00000000;
 701   1      
 702   1        Mmillon=0x00;
 703   1        cmillon=0x00;
 704   1        dmillon=0x00;
 705   1        millon=0x00;
 706   1        cmil=0x00;
 707   1        dmil=0x00;
 708   1        mil=0x00;
 709   1        centena=0x00;
 710   1        decena=0x00;
 711   1        unidad=0x00;
 712   1      
 713   1      
 714   1      //  tx_chr(Mmillon);
 715   1      //  tx_chr(cmillon);
 716   1      //  tx_chr(dmillon);
 717   1      //  tx_chr(millon);
 718   1      //  tx_chr(cmil);
 719   1      //  tx_chr(dmil);
 720   1      //  tx_chr(mil);
 721   1      //  tx_chr(centena);
 722   1      //  tx_chr(millon);
 723   1      //  tx_chr(cmil);
 724   1      
 725   1        valor=valor|fc;
 726   1        valor<<=8;
 727   1        valor=valor|id_h;
 728   1        valor<<=8;
 729   1        valor=valor|id_l;
 730   1        valor<<=8;
 731   1        valor=valor|id_l2;
 732   1        numero=valor;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 13  

 733   1      
 734   1      
 735   1        while (numero>=0x3B9ACA00)      // resto 1.000.000.000 
 736   1        {
 737   2          numero=numero-0x3B9ACA00;
 738   2          Mmillon++;
 739   2        }
 740   1        Mmillon=Mmillon|0x30;
 741   1      //  tx_chr(Mmillon);
 742   1      
 743   1        while (numero>=0x05F5E100)      // resto 100.000.000 
 744   1        {
 745   2          numero=numero-0x05F5E100;
 746   2          cmillon++;
 747   2        }
 748   1        cmillon=cmillon|0x30;
 749   1      //  tx_chr(cmillon);
 750   1      
 751   1        while (numero>=0x00989680)      // resto 10.000.000 
 752   1        {
 753   2          numero=numero-0x00989680;
 754   2          dmillon++;
 755   2        }
 756   1        dmillon=dmillon|0x30;
 757   1      //  tx_chr(dmillon);
 758   1      
 759   1        while (numero>=0x000f4240)      // resto 1.000.000 
 760   1        {
 761   2          numero=numero-0x000f4240;
 762   2          millon=millon+1;
 763   2        }
 764   1        millon=millon|0x30;
 765   1      //  tx_chr(millon);
 766   1      
 767   1        while (numero>=0x000186a0)      // resto 100.000 
 768   1        {
 769   2          numero=numero-0x000186a0;
 770   2          cmil=cmil+1;
 771   2        }
 772   1        cmil=cmil|0x30;
 773   1      //  tx_chr(cmil);
 774   1      
 775   1        while (numero>=0x2710)        // resto 10.000 
 776   1        {
 777   2          numero=numero-0x2710;
 778   2          dmil=dmil+1;
 779   2        }
 780   1        dmil=dmil|0x30;
 781   1      //  tx_chr(dmil);
 782   1      
 783   1        while (numero>=0x03e8)        // resto 1.000
 784   1        {
 785   2          numero=numero-0x03e8;
 786   2          mil=mil+1;
 787   2        }
 788   1        mil=mil|0x30;
 789   1      //  tx_chr(mil);
 790   1      
 791   1        while (numero>=0x064)         // resto 100
 792   1        {
 793   2          numero=numero-0x64;
 794   2          centena=centena+1;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 14  

 795   2        }
 796   1        centena=centena|0x30;
 797   1      //  tx_chr(centena);
 798   1      
 799   1        while (numero>=0x0a)        // resto 10
 800   1        {
 801   2          numero=numero-0x0a;
 802   2          decena=decena+1;
 803   2        }
 804   1        decena=decena|0x30;
 805   1      //  tx_chr(decena);
 806   1      
 807   1        unidad=numero;            // 1
 808   1        unidad=unidad|0x30;
 809   1      //  tx_chr(unidad);
 810   1      
 811   1      //  tx_chr(0x0d);
 812   1      //  tx_chr(0x0a);
 813   1      //------------------------------------------------------------------
 814   1        vdato(Mmillon);
 815   1      
 816   1        vdato(cmillon);
 817   1        vdato(dmillon);
 818   1        vdato(millon);
 819   1      
 820   1        vdato(cmil);
 821   1        vdato(dmil);
 822   1        vdato(mil);
 823   1        
 824   1        vdato(centena);
 825   1        vdato(decena);
 826   1        vdato(unidad);
 827   1      //------------------------------------------------------------------
 828   1        if (xTIPO=='U')
 829   1        {
 830   2          num_data=15;
 831   2            buffer_bus[0]=STX;
 832   2            buffer_bus[1]='0';
 833   2            buffer_bus[2]=15;
 834   2          buffer_bus[3]='U';
 835   2          buffer_bus[4]=Mmillon;
 836   2          buffer_bus[5]=cmillon;
 837   2          buffer_bus[6]=dmillon;
 838   2          buffer_bus[7]=millon;
 839   2          buffer_bus[8]=cmil;
 840   2          buffer_bus[9]=dmil;
 841   2          buffer_bus[10]=mil;
 842   2          buffer_bus[11]=centena;
 843   2          buffer_bus[12]=decena;
 844   2          buffer_bus[13]=unidad;
 845   2          buffer_bus[14]=ETX;  
 846   2        }
 847   1        if (xTIPO=='D')
 848   1        {
 849   2      
 850   2          for (j=0; j<16; j++)
 851   2          {
 852   3            buffer_name[j]=buffer_bus[11+j];
 853   3          }
 854   2      
 855   2            num_data=34;
 856   2            buffer_bus[0]=STX;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 15  

 857   2            buffer_bus[1]='0';
 858   2            buffer_bus[2]=num_data;
 859   2          buffer_bus[3]='v';
 860   2          buffer_bus[4]=':';
 861   2          buffer_bus[5]=Mmillon;
 862   2          buffer_bus[6]=cmillon;
 863   2          buffer_bus[7]=dmillon;
 864   2          buffer_bus[8]=millon;
 865   2          buffer_bus[9]=cmil;
 866   2          buffer_bus[10]=dmil;
 867   2          buffer_bus[11]=mil;
 868   2          buffer_bus[12]=centena;
 869   2          buffer_bus[13]=decena;
 870   2          buffer_bus[14]=unidad;
 871   2          buffer_bus[15]=':';
 872   2          for (j=0; j<16; j++)
 873   2          {
 874   3            buffer_bus[j+16]=buffer_name[j];
 875   3          }
 876   2          buffer_bus[32]=':';
 877   2          buffer_bus[33]=ETX;  
 878   2        }
 879   1        else                  // if (TIPO=='T')
 880   1        {
 881   2          num_data=18;
 882   2            buffer_bus[0]=STX;
 883   2            buffer_bus[1]='0';
 884   2            buffer_bus[2]=18;
 885   2          buffer_bus[3]='T';
 886   2          buffer_bus[4]=':';
 887   2          buffer_bus[5]=xTIPO;
 888   2          buffer_bus[6]=':';
 889   2          buffer_bus[7]=Mmillon;
 890   2          buffer_bus[8]=cmillon;
 891   2          buffer_bus[9]=dmillon;
 892   2          buffer_bus[10]=millon;
 893   2          buffer_bus[11]=cmil;
 894   2          buffer_bus[12]=dmil;
 895   2          buffer_bus[13]=mil;
 896   2          buffer_bus[14]=centena;
 897   2          buffer_bus[15]=decena;
 898   2          buffer_bus[16]=unidad;
 899   2          buffer_bus[17]=ETX;  
 900   2      
 901   2        }
 902   1      //-------------------------------------------------------------------
 903   1      }   
 904          //******************************************************************************************
 905          //*******************************************************************************************
 906           unsigned char bcd_dec (unsigned char data_clk)
 907           {
 908   1        unsigned char temp,j;
 909   1        temp=data_clk;
 910   1        temp>>=4;
 911   1        temp=temp & 0x0f;
 912   1        if (temp!=0x00)
 913   1        {
 914   2          data_clk=data_clk & 0x0f;
 915   2          for (j=0;j<temp;j++)
 916   2          {
 917   3             data_clk=data_clk+0x0a;
 918   3          } 
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 16  

 919   2        }
 920   1        byte=(data_clk+0x30);
 921   1        return byte;
 922   1       }
 923          //*******************************************************************************************
 924           unsigned char bcd_hex (unsigned char l_data)
 925           {
 926   1        unsigned char temp,j;
 927   1        temp=l_data;
 928   1        temp>>=4;
 929   1        temp=temp & 0x0f;
 930   1        if (temp!=0x00)
 931   1        {
 932   2          l_data=l_data & 0x0f;
 933   2          for (j=0;j<temp;j++)
 934   2          {
 935   3              l_data=l_data+0x0a;
 936   3          } 
 937   2        }
 938   1        return l_data;
 939   1       }
 940          //*******************************************************************************************
 941          //*******************************************************************************************
 942          //    Transforma HEX to BCD                               *
 943          //*******************************************************************************************
 944          unsigned char transf (unsigned char byte)
 945          {
 946   1          unsigned char nibble_h; 
 947   1        unsigned char nibble_l;
 948   1        unsigned char k;
 949   1      
 950   1        nibble_h=0x00;
 951   1        nibble_l=0x00;
 952   1         
 953   1        if (byte > 0x30)
 954   1        {
 955   2          byte=byte-0x30;
 956   2           for (k=0;k<byte;k++)
 957   2           {
 958   3            nibble_l=nibble_l+0x01;
 959   3            if (nibble_l==0x0a)
 960   3            {
 961   4              nibble_l=0x00;
 962   4              nibble_h=nibble_h+0x01;
 963   4            }
 964   3           }
 965   2           nibble_h<<=4;
 966   2           nibble_h=nibble_h & 0xf0;
 967   2           nibble_l=nibble_l & 0x0f;
 968   2           byte_out=(nibble_h | nibble_l);
 969   2           return byte_out;
 970   2        }
 971   1        return byte_out;
 972   1      }
 973          //*******************************************************************************************
 974          //*******************************************************************************************
 975          //    Transforma HEX Nativo to BCD                            *
 976          //*******************************************************************************************
 977          unsigned char hex_bcd (unsigned char byte)
 978          {
 979   1          unsigned char nibble_h; 
 980   1        unsigned char nibble_l;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 17  

 981   1        unsigned char k;
 982   1      
 983   1        nibble_h=0x00;
 984   1        nibble_l=0x00;
 985   1      
 986   1        for (k=0;k<byte;k++)
 987   1        {
 988   2          nibble_l=nibble_l+0x01;
 989   2          if (nibble_l==0x0a)
 990   2          {
 991   3            nibble_l=0x00;
 992   3            nibble_h=nibble_h+0x01;
 993   3          }
 994   2         }
 995   1         nibble_h<<=4;
 996   1         nibble_h=nibble_h & 0xf0;
 997   1         nibble_l=nibble_l & 0x0f;
 998   1         byte_out=(nibble_h | nibble_l);
 999   1         return byte_out;
1000   1        
1001   1      }
1002          //*******************************************************************************************
1003          //  CONVIERTE DE 1BYTE HEXADECIMAL A DECIMAL Y LOS VE EN DISPLAY              *
1004          //*******************************************************************************************
1005          void ve_num(unsigned char valorhex)
1006          {
1007   1        unsigned char numero, centena, decena, unidad;
1008   1      
1009   1        decena=0;
1010   1        unidad=0;
1011   1        numero=valorhex;
1012   1      
1013   1        while (numero>=0x064)         // resto 100
1014   1        {
1015   2          numero=numero-0x64;
1016   2          centena=centena+1;
1017   2        }
1018   1        while (numero>=0x0a)        // resto 10
1019   1        {
1020   2          numero=numero-0x0a;
1021   2          decena=decena+1;
1022   2        }
1023   1        unidad=numero;
1024   1        vdato(decena|0x30);
1025   1        vdato(unidad|0x30);
1026   1      }
1027          //*******************************************************************************************
1028          //*******************************************************************************************
1029          
1030          //*******************************************************************************************
1031          //    FUNCIONES PARA VISUALIZAR FECHA HORA                        *
1032          //*******************************************************************************************
1033           void vdata_clk (unsigned char data_clk) 
1034           {
1035   1       
1036   1       unsigned int temp;
1037   1      
1038   1       temp=data_clk;
1039   1       temp=temp & 0xf0;
1040   1       temp>>=4;
1041   1       temp=temp|0x30;
1042   1       vdato(temp);
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 18  

1043   1      
1044   1       temp=data_clk;
1045   1       temp=temp & 0x0f;
1046   1       temp=temp|0x30;
1047   1       vdato(temp);
1048   1      
1049   1      }
1050          
1051          //*******************************************************************************************
1052          
1053          //*******************************************************************************************
1054          
1055          //*******************************************************************************************
1056          //  CONDICIONES INICIALES                                 *
1057          //*******************************************************************************************
1058          void cond_ini(void)
1059          {
1060   1      //------------------------------------------------------------------------------------------*
1061   1      //Condiciones iniciales de hardware
1062   1      //------------------------------------------------------------------------------------------*
1063   1      
1064   1        ledv=0;
1065   1          lock1=0; 
1066   1      //  if (lock2==1)       //Lo configura de entrada. Es usado por Procesador 2, para ERR
1067   1      //  {
1068   1      //  }  
1069   1        lock2=0;
1070   1      //  cajon=1;
1071   1      //------------------------------------------------------------------------------------------*
1072   1        E=1;          //Display
1073   1        RS=1;
1074   1      //------------------------------------------------------------------------------------------*
1075   1      //  sck=0;          //Reloj
1076   1      //  rst=0;
1077   1      //  io=1;
1078   1      //------------------------------------------------------------------------------------------*
1079   1      //  sda=1;          //Memoria
1080   1      //  scl=1;    
1081   1      //------------------------------------------------------------------------------------------*
1082   1      //Condiciones Iniciales de variables de Acceso
1083   1      //------------------------------------------------------------------------------------------*
1084   1      //  buffer_wie[0]=0xff;
1085   1      //  buffer_wie[1]=0xff;
1086   1      //  buffer_wie[2]=0xff;
1087   1      //  buffer_wie[3]=0xff;
1088   1      //  buffer_wie[4]=0xff;
1089   1      
1090   1      //------------------------------------------------------------------------------------------*
1091   1      //Condiciones Iniciales de variables de Controlador
1092   1      //------------------------------------------------------------------------------------------*
1093   1      
1094   1      //------------------------------------------------------------------------------------------*
1095   1      //Condiciones Iniciales de variables de Comunicaciones
1096   1      //------------------------------------------------------------------------------------------*
1097   1      
1098   1      //------------------------------------------------------------------------------------------*
1099   1      //Condiciones Iniciales de variables de Tiempo
1100   1      //------------------------------------------------------------------------------------------*
1101   1        error_com=0;
1102   1      
1103   1      
1104   1      }
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 19  

1105          //*******************************************************************************************
1106          //*******************************************************************************************
1107          void ve_dir(void)
1108          {
1109   1        sw_1=0;
1110   1        sw_2=0;
1111   1      
1112   1        wait_long();
1113   1          g_cDirBoard=0x30;
1114   1      
1115   1        if (sw_1==1)
1116   1        {
1117   2          g_cDirBoard++;
1118   2        }
1119   1        if (sw_2==1)
1120   1        {
1121   2          g_cDirBoard=g_cDirBoard+2;
1122   2        }
1123   1        cont(0xc9);
1124   1        vdato(g_cDirBoard);
1125   1      }
1126          //********************************************************************************************************
             -******
1127          void AtencComSoft(void)
1128          {
1129   1      
1130   1      unsigned char j, longTx, num_chrL1, num_chrL2;
1131   1      
1132   1        switch (g_cCMD_Soft)
1133   1        {
1134   2      //--------------------------------------------------------------------------------------------------------
             -------
1135   2          case SIN_CMD:
1136   2      
1137   2      
1138   2          break;
1139   2      //--------------------------------------------------------------------------------------------------------
             -------
1140   2          case POLL_COM_SOF:
1141   2            if (g_cEstadoTxSoft==SIN_LECTURA_TX)
1142   2            {       
1143   3              txACK=1;                            //No hay Novedad
1144   3            }
1145   2      //--------------------------------------------------------------------------------------------------------
             -------
1146   2            else if ((g_cEstadoTxSoft&LECTURA_COD_TX)==LECTURA_COD_TX)      // Lectura Cod Barras
1147   2            {                                 // Expedidor
1148   3                longTx=len_buffer;
1149   3                for (j=0; j<len_buffer; j++)
1150   3                  {
1151   4                  g_scArrTxComSoft[j]=buffer_ticket[j];
1152   4                  }
1153   3      //            buffer_ticket[0]=STX;
1154   3      //          buffer_ticket[len_buffer-1]=ETX;
1155   3      
1156   3                EscribirCadenaSoft(longTx);
1157   3                g_cEstadoComSoft=ESPERA_RX;
1158   3                g_cCMD_Soft=SIN_CMD;
1159   3      
1160   3      
1161   3            }
1162   2      //--------------------------------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 20  

             -------
1163   2            else if ((g_cEstadoTxSoft&ERROR_INFO)==ERROR_INFO)      
1164   2            {                               
1165   3        
1166   3                longTx=len_buffer;
1167   3                for (j=0; j<len_buffer; j++)
1168   3                  {
1169   4                  g_scArrTxComSoft[j]=buffer_ticket[j];
1170   4                  }
1171   3                  EscribirCadenaSoft(longTx);
1172   3                g_cEstadoComSoft=ESPERA_RX;
1173   3                g_cCMD_Soft=SIN_CMD;
1174   3      
1175   3            }
1176   2      //--------------------------------------------------------------------------------------------------------
             ----------
1177   2              else if ((g_cEstadoTxSoft&ERROR_WR_CARD)==ERROR_WR_CARD)            // 
1178   2            {
1179   3              g_scArrTxComSoft[0]=STX;                    
1180   3              g_scArrTxComSoft[1]=g_cDirBoard;
1181   3              g_scArrTxComSoft[2]=0X06;
1182   3              g_scArrTxComSoft[3]='G';
1183   3              g_scArrTxComSoft[4]='1';
1184   3              g_scArrTxComSoft[5]=ETX;
1185   3              EscribirCadenaSoft(6);
1186   3              g_cEstadoComSoft=ESPERA_RX;
1187   3              g_cCMD_Soft=SIN_CMD;
1188   3      //        g_cEstadoTxSoft &=~ERROR_WR_CARD;                     
1189   3            }
1190   2      //--------------------------------------------------------------------------------------------------------
             ---------      
1191   2              else if ((g_cEstadoTxSoft&APERTURA_PUERTA)==APERTURA_PUERTA)            // 
1192   2            {
1193   3                g_scArrTxComSoft[0]=STX;
1194   3              g_scArrTxComSoft[1]='0';
1195   3                g_scArrTxComSoft[2]=0X06;
1196   3              g_scArrTxComSoft[3]='S';
1197   3              g_scArrTxComSoft[4]='1';
1198   3                g_scArrTxComSoft[5]=ETX;
1199   3              EscribirCadenaSoft(6);
1200   3              g_cEstadoComSoft=ESPERA_RX;
1201   3              g_cCMD_Soft=SIN_CMD;
1202   3            }
1203   2      //--------------------------------------------------------------------------------------------------------
             ---------      
1204   2              else if ((g_cEstadoTxSoft&RETIRO_COFRE_B2B)==RETIRO_COFRE_B2B)            // 
1205   2            {
1206   3                g_scArrTxComSoft[0]=STX;
1207   3              g_scArrTxComSoft[1]='0';
1208   3                g_scArrTxComSoft[2]=0X06;
1209   3              g_scArrTxComSoft[3]='S';
1210   3              g_scArrTxComSoft[4]='2';
1211   3                g_scArrTxComSoft[5]=ETX;
1212   3              EscribirCadenaSoft(6);
1213   3              g_cEstadoComSoft=ESPERA_RX;
1214   3              g_cCMD_Soft=SIN_CMD;
1215   3            } 
1216   2      //--------------------------------------------------------------------------------------------------------
             --------
1217   2              else if ((g_cEstadoTxSoft&RETIRO_COFRE_COIN)==RETIRO_COFRE_COIN)          //
1218   2            {
1219   3                g_scArrTxComSoft[0]=STX;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 21  

1220   3              g_scArrTxComSoft[1]='0';
1221   3                g_scArrTxComSoft[2]=0X06;
1222   3              g_scArrTxComSoft[3]='S';
1223   3              g_scArrTxComSoft[4]='3';
1224   3                g_scArrTxComSoft[5]=ETX;
1225   3              EscribirCadenaSoft(6);
1226   3              g_cEstadoComSoft=ESPERA_RX;
1227   3              g_cCMD_Soft=SIN_CMD;
1228   3            }                             
1229   2          break;
1230   2      //********************************************************************************************************
             -******
1231   2          case APERTURA:                                        //
1232   2      
1233   2            flag_segundo=0;
1234   2            seg=cte_seg;
1235   2            TH0=0X00;               
1236   2            TL0=0X00;
1237   2            TF0=0;
1238   2            txACK=1;
1239   2            buffer_bus[3]=0x00;   
1240   2                                      
1241   2          break;
1242   2      //********************************************************************************************************
             -******
1243   2          case WR_SECTORMF:
1244   2      
1245   2              for (j=0; j<g_cContByteRx; j++)
1246   2            {
1247   3              buffer_bus[j]= g_scArrRxComSoft[j];
1248   3            }
1249   2            tx_bus(g_cContByteRx);
1250   2            g_cEstadoComSoft=ESPERA_RX;
1251   2            g_cCMD_Soft=SIN_CMD;
1252   2      
1253   2          break;
1254   2      //********************************************************************************************************
             -******
1255   2          case EJECT_WR:                                      //ANALIZA DATOS RECIBIDOS
1256   2          
1257   2      
1258   2            cont(0x80);
1259   2            for (j=0; j<16; j++)
1260   2            {
1261   3              buffer_bus[j]= g_scArrRxComSoft[j];
1262   3              vdato(g_scArrRxComSoft[j]);
1263   3            }
1264   2            
1265   2      
1266   2            if (ready==1)
1267   2            {
1268   3              
1269   3              if (Grabacion==1)
1270   3              {
1271   4                tx_chr(ACK);
1272   4              }
1273   3      
1274   3      
1275   3              tx_bus(16);
1276   3      
1277   3              g_cEstadoTxSoft &=~LECTURA_COD_TX;
1278   3              g_cEstadoComSoft=ESPERA_RX; 
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 22  

1279   3              g_cCMD_Soft=SIN_CMD;
1280   3            }
1281   2            
1282   2        
1283   2                                      
1284   2          break;
1285   2      //********************************************************************************************************
             -******
1286   2          case EJECT_WR2:                                     
1287   2          
1288   2            
1289   2              if (ready==1)
1290   2            {
1291   3      
1292   3              for (j=0; j<21; j++)
1293   3              {
1294   4                buffer_bus[j]= g_scArrRxComSoft[j];
1295   4              }
1296   3              cont(0x80);
1297   3              for (j=12; j<20; j++)
1298   3              {
1299   4                vdato(g_scArrRxComSoft[j]);
1300   4              }
1301   3      
1302   3              tx_bus(21);
1303   3      
1304   3              g_cEstadoTxSoft &=~LECTURA_COD_TX;
1305   3              g_cEstadoComSoft=ESPERA_RX; 
1306   3              g_cCMD_Soft=SIN_CMD;
1307   3              if (Grabacion==1)
1308   3              {
1309   4                tx_chr(ACK);
1310   4              }
1311   3            }
1312   2            
1313   2        
1314   2                                      
1315   2          break;
1316   2      //********************************************************************************************************
             -******
1317   2      //********************************************************************************************************
             -******
1318   2          case EJECT:                                     
1319   2          
1320   2              if (ready==1)
1321   2            {
1322   3                  
1323   3              buffer_bus[0]=STX;
1324   3              buffer_bus[1]='0';
1325   3              buffer_bus[2]=0x05;
1326   3              buffer_bus[3]='O';
1327   3              buffer_bus[4]=ETX;
1328   3        
1329   3              Rta_Send=tx_bus(0x05);
1330   3              if (Rta_Send==1)
1331   3              {
1332   4         
1333   4                cont(0x80);
1334   4                for (j=0; j<16; j++)
1335   4                {
1336   5                  vdato(' ');
1337   5                }
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 23  

1338   4                cont(0xc0);
1339   4                for (j=0; j<16; j++)
1340   4                {
1341   5                  vdato(CMD_Out[j]);
1342   5                }      
1343   4         
1344   4                Rta_Send=0;
1345   4                g_cEstadoTxSoft &=~LECTURA_COD_TX;
1346   4                g_cCMD_Soft=SIN_CMD;
1347   4                g_cEstadoComSoft=ESPERA_RX;
1348   4              }
1349   3              else
1350   3              {
1351   4                g_cCMD_Soft=EJECT;
1352   4              }
1353   3              }
1354   2      
1355   2                                      
1356   2          break;
1357   2      //********************************************************************************************************
             -******
1358   2          case USUARIOT:                                      //ANALIZA DATOS RECIBIDOS
1359   2          
1360   2              if ((NIVEL>0X30)&&(NIVEL<=0X39))
1361   2            {
1362   3              cont(0x80);
1363   3              for (j=0; j<16 ;j++)
1364   3              {
1365   4                  vdato(' ');
1366   4              }
1367   3        
1368   3        
1369   3              g_cEstadoTxSoft &=~LECTURA_COD_TX;
1370   3              buffer_bus[0]=STX;
1371   3              buffer_bus[1]=0x30;
1372   3              buffer_bus[2]=6;
1373   3              buffer_bus[3]='U';
1374   3              buffer_bus[4]=NIVEL;
1375   3              buffer_bus[5]=ETX;
1376   3              tx_bus(6);
1377   3              buffer_bus[3]=0x00;
1378   3              g_cCMD_Soft=SIN_CMD;
1379   3            }
1380   2                                      
1381   2          break;
1382   2      //********************************************************************************************************
             -******
1383   2          case EXIT:                                      //ANALIZA DATOS RECIBIDOS
1384   2          
1385   2      
1386   2            cont(0x80);
1387   2            for (j=0; j<16 ;j++)
1388   2            {
1389   3                vdato(' ');
1390   3            }
1391   2      
1392   2            cont(0xc0);
1393   2            for (j=0;linea[j]!='\0';j++)
1394   2            {
1395   3                vdato(linea[j]);
1396   3            }
1397   2      
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 24  

1398   2              FueraServicio=0;
1399   2            g_cEstadoTxSoft &=~LECTURA_COD_TX;
1400   2      
1401   2            buffer_bus[0]=STX;
1402   2            buffer_bus[1]=0x30;
1403   2            buffer_bus[2]=0x05;
1404   2            buffer_bus[3]='E';
1405   2            buffer_bus[4]=ETX;
1406   2            tx_bus(0x05);
1407   2            buffer_bus[3]=0x00;
1408   2            g_cCMD_Soft=SIN_CMD;
1409   2      
1410   2                                      
1411   2          break;
1412   2      //********************************************************************************************************
             -******
1413   2          case FUERASERV:                                     //ANALIZA DATOS RECIBIDOS
1414   2          
1415   2      
1416   2            cont(0x80);
1417   2            for (j=0; j<16 ;j++)
1418   2            {
1419   3                vdato(' ');
1420   3            }
1421   2      
1422   2            cont(0xc0);
1423   2            for (j=0;FueraServ[j]!='\0';j++)
1424   2            {
1425   3                vdato(FueraServ[j]);
1426   3            }
1427   2      
1428   2      
1429   2            g_cEstadoTxSoft =0;
1430   2      
1431   2            buffer_bus[0]=STX;
1432   2            buffer_bus[1]=0x30;
1433   2            buffer_bus[2]=0x05;
1434   2            buffer_bus[3]='F';
1435   2            buffer_bus[4]=ETX;
1436   2            tx_bus(0x05);
1437   2            buffer_bus[3]=0x00;
1438   2            g_cCMD_Soft=SIN_CMD;
1439   2      
1440   2       
1441   2                                      
1442   2          break;
1443   2      //********************************************************************************************************
             -******
1444   2          case CANCELO:                                     //ANALIZA DATOS RECIBIDOS
1445   2          
1446   2            cont(0x80);
1447   2            for (j=0; j<16 ;j++)
1448   2            {
1449   3              vdato(' ');
1450   3            }
1451   2            cont(0xc0);
1452   2            for (j=0; j<16 ;j++)
1453   2            {
1454   3              vdato(linea[j]);
1455   3            }
1456   2          
1457   2            buffer_bus[0]=STX;
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 25  

1458   2            buffer_bus[1]=0x30;
1459   2            buffer_bus[2]=0x05;
1460   2            buffer_bus[3]='o';
1461   2            buffer_bus[4]=ETX;
1462   2            tx_bus(0x05);
1463   2      
1464   2            Electroiman=1;
1465   2      
1466   2            g_cEstadoComSoft=ESPERA_RX; 
1467   2            g_cEstadoTxSoft=SIN_LECTURA_TX;
1468   2            g_cCMD_Soft=SIN_CMD;            
1469   2                                    
1470   2          break;
1471   2      //********************************************************************************************************
             -***
1472   2          case WR_DISPLAY:
1473   2            
1474   2            if (g_cContByteRx>5)            // min 1 dato para el display
1475   2            {
1476   3              prg_disp();
1477   3              if (g_cContByteRx>21)
1478   3              {
1479   4                cont(0x80);
1480   4                for (j=0; j<16; j++)
1481   4                {
1482   5                  vdato(g_scArrRxComSoft[4+j]);
1483   5                } 
1484   4                cont(0xc0);
1485   4                num_chrL2=g_cContByteRx-21;
1486   4                for (j=0; j<num_chrL2; j++)
1487   4                {
1488   5                  vdato(g_scArrRxComSoft[20+j]);
1489   5                }
1490   4              }
1491   3              else
1492   3              {
1493   4                num_chrL1=g_cContByteRx-5;
1494   4                cont(0x80);
1495   4                for (j=0; j<num_chrL1; j++)
1496   4                {
1497   5                  vdato(g_scArrRxComSoft[4+j]);
1498   5                } 
1499   4              }
1500   3              txACK=1;
1501   3            }
1502   2            else
1503   2            {
1504   3              g_cCMD_Soft=SIN_CMD;
1505   3            }
1506   2            buffer_bus[3]=0x00;
1507   2            
1508   2      
1509   2          break;
1510   2      //------------------------------------------------------------------------------------------*
1511   2          default:
1512   2            g_cCMD_Soft=SIN_CMD;
1513   2          break;
1514   2        
1515   2        }
1516   1      } //void AtencComSoft(void)
1517          //*******************************************************************************************
1518          //*******************************************************************************************
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 26  

1519          //*******************************************************************************************
1520          //                                              *
1521          // Function to initialize the serial port and the UART baudrate.              *
1522          //                                              *
1523          //*******************************************************************************************
1524          void com_initialize (void) 
1525          {
1526   1          sendactive = 0;               // transmitter is not active              *
1527   1          SCON = 0x50;                // serial port MODE 1, enable serial receiver   *
1528   1        PCON |= 0x80;                 // 0x80=SMOD: set serial baudrate doubler     *
1529   1          TMOD |= 0x20;                 // put timer 1 into MODE 2              *
1530   1        TCON = 0x40;              // TCON                       *
1531   1      //------------------------------------------------------------------------------------------*
1532   1      //  TH1 =  0xFF;              // TH1  115000 Bps @ 22.148MHZ            *
1533   1      //  TL1 =  0xFF;              // TH1                        *
1534   1      //------------------------------------------------------------------------------------------*
1535   1        TH1 =  0xF4;              // TH1 9600 Bps @ 22.148MHZ             *          
1536   1        TL1 =  0xF4;              // TH1                        *
1537   1      //------------------------------------------------------------------------------------------*
1538   1      //  TH1 = (unsigned char) (256 - (XTAL / (16L * 12L * baudrate)));              *
1539   1      //------------------------------------------------------------------------------------------*
1540   1          TR1 = 1;              // start timer 1
1541   1          ES = 1;               // enable serial interrupts
1542   1      }
1543          //*******************************************************************************************
1544          
1545          //******************************************************************************************* 
1546          //  PROGRAMA PRINCIPAL                                    *
1547          //*******************************************************************************************
1548          //*******************************************************************************************
1549          void main (void)  
1550          {
1551   1      
1552   1       unsigned char msgdir   []= "   Addr:        " ;  
1553   1       unsigned char lect_cod []= "LECT.           " ;
1554   1      
1555   1       extern unsigned char rx_wiegand_l1(void);
1556   1      
1557   1      // unsigned char confirmacion []= "  LIBERE PULSADOR" ;
1558   1      // unsigned char borrando     []= "  BORRANDO MEMORIA" ;
1559   1      
1560   1       unsigned char msgformato   []= "GRABACION USUARIOS" ;
1561   1       unsigned char msgCOMPRA   []= "COMPRA DESCUENTO" ;
1562   1       unsigned char clr_display []= "                ";
1563   1      
1564   1       unsigned int k;
1565   1       unsigned char Pos_Coma;
1566   1      //*******************************************************************************************
1567   1      
1568   1      //*******************************************************************************************
1569   1        cond_ini();             // CONDICIONES INICIALES              *
1570   1          txEOT=0;
1571   1        txACK=0;
1572   1        Electroiman=1;
1573   1      //*******************************************************************************************
1574   1      //******************************************************************************************* 
1575   1          TF2=0;                //  Bandera de Timer                *
1576   1        TH2=0X00;             //                          *           
1577   1        TL2=0X00;             //                          *
1578   1        TR2=1;                // Run Timer 0                    *
1579   1      //******************************************************************************************* 
1580   1          EA = 1;                             // Enable global interrupts             *
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 27  

1581   1          com_initialize ();                  // Initialize interrupt driven serial I/O       *
1582   1      //******************************************************************************************* 
1583   1        TMOD=(TMOD & 0xf0) | 0x01;      //  Coloca el temporizador 0 y 1 en modo 1.  16bITS *
1584   1        TF0=0;                //  Bandera de Timer                *
1585   1        TH0=0X00;             //                          *           
1586   1        TL0=0X00;             //                          *
1587   1        TR0=1;                // Run TM2                      *
1588   1      //******************************************************************************************* 
1589   1      //*******************************************************************************************
1590   1        prg_disp()  ;                 // PROGRAMA DISPALY           *         
1591   1      //------------------------------------------------------------------------------------------*
1592   1      //  PROCESO DE RESET                                    *
1593   1      //------------------------------------------------------------------------------------------*
1594   1        msg1=0;
1595   1        audio1=0;
1596   1      
1597   1        msg2=0;
1598   1        audio2=0;
1599   1      
1600   1        msg3=0;
1601   1        audio3=0;
1602   1      
1603   1        msg4=0;
1604   1        audio4=0;
1605   1      
1606   1        Estado_Luz=0x01;
1607   1        Time_Devolucion=0;
1608   1        Grabacion=0;
1609   1      //------------------------------------------------------------------------------------------*
1610   1      //    MENSAJE INICIAL                                     *
1611   1      //------------------------------------------------------------------------------------------*
1612   1                  
1613   1      //   cont(0x80);
1614   1      //  for (k=0;expedidor[k]!='\0';k++)    
1615   1      //  {
1616   1      //    vdato(expedidor[k]);
1617   1      //  }
1618   1      
1619   1      
1620   1        flag_segundo=0;           //Debe actualizar display en 1 segundo
1621   1        contador=0;
1622   1        seg=cte_seg;
1623   1        seg2=0;
1624   1        byte=0xff;
1625   1      
1626   1        byte=8;
1627   1        TimeOut_Codigo=0;
1628   1        retry=0;
1629   1        TimeOutLinea=TIMEW;
1630   1        g_cCMD_Soft=SIN_CMD;
1631   1        g_cEstadoComSoft=ESPERA_RX;
1632   1        txRTA=0;
1633   1        FueraServicio=0;
1634   1        g_cEstadoTxSoft=SIN_LECTURA_TX;
1635   1      //*******************************************************************************************
1636   1      //  USE_LPR=0;
1637   1      //*******************************************************************************************
1638   1      //      RECIBE DIR                                    *
1639   1      //*******************************************************************************************
1640   1        cont(0xc0);
1641   1        for (k=0; linea[k]!='\0';k++)
1642   1        {
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 28  

1643   2          vdato(linea[k]);
1644   2        }                   //                          *
1645   1      //*******************************************************************************************
1646   1      //      LOOP PRINCIPAL                                  *
1647   1      //*******************************************************************************************
1648   1        busy=1;
1649   1        bus_clk=1;
1650   1      //*******************************************************************************************
1651   1        while (1)                     // Loop Principal           * 
1652   1        {                                 
1653   2          P2=0xff;
1654   2          temp=P2;
1655   2      //------------------------------------------------------------------------------------------*
1656   2      //------------------------------------------------------------------------------------------*
1657   2          AtencComSoft();
1658   2      //------------------------------------------------------------------------------------------*
1659   2      //    INTERRUPCION DEL AUXILIAR
1660   2      //------------------------------------------------------------------------------------------*
1661   2          if (ready==0)                   //(Interrupcion generada del Aux)
1662   2          {
1663   3            buffer_bus[0]=0xff;
1664   3            rx_bus();
1665   3        
1666   3            if (num_data!=0)
1667   3            {
1668   4      //------------------------------------------------------------------------------------------*
1669   4              len_buffer=num_data;
1670   4      //        for (k=0; k<len_buffer; k++)
1671   4      //        {
1672   4      //          tx_chr(buffer_bus[k]);
1673   4      //        }
1674   4      //------------------------------------------------------------------------------------------* 
1675   4              seg2=cte_seg*4;
1676   4      
1677   4              if ((buffer_bus[0]==0x02))   
1678   4              {
1679   5      
1680   5                
1681   5                if ((buffer_bus[3]=='L')||(buffer_bus[3]=='T')||(buffer_bus[3]=='U')||(buffer_bus[3]=='A')||(buffer_b
             -us[3]=='p')||(buffer_bus[3]=='Q'))//adicione Q
1682   5                {
1683   6                  
1684   6                    Estado_Luz=0x02;
1685   6                    Grabacion=0;
1686   6      
1687   6                  if (buffer_bus[3]=='U')
1688   6                  {
1689   7                      cont(0x80);
1690   7                    for (k=0;lect_cod[k]!='\0';k++)
1691   7                    {
1692   8                      vdato(lect_cod[k]);
1693   8                    }
1694   7                    cont(0x86);
1695   7                    ve_id('U',buffer_bus[4],buffer_bus[5],buffer_bus[6],buffer_bus[7]);
1696   7                  }
1697   6                  else if ((buffer_bus[3]=='T')&&(buffer_bus[5]=='D'))          // T:D   TARJETA COMPRA DESCUENTO
1698   6                  {
1699   7                    cont(0xc0);
1700   7                    for (k=0;msgCOMPRA[k]!='\0';k++)
1701   7                    {
1702   8                      vdato(msgCOMPRA[k]);
1703   8                    }
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 29  

1704   7                    
1705   7                      cont(0x80);
1706   7                    for (k=0;lect_cod[k]!='\0';k++)
1707   7                    {
1708   8                      vdato(lect_cod[k]);
1709   8                    }
1710   7                    cont(0x86);             
1711   7                    ve_id('D',buffer_bus[6],buffer_bus[7],buffer_bus[8],buffer_bus[9]);
1712   7      
1713   7                  
1714   7                  }
1715   6                  else if ((buffer_bus[3]=='T')&&(buffer_bus[5]=='0'))          // T:0   CREA TARJETAS
1716   6                  {
1717   7                    cont(0xc0);
1718   7                    for (k=0;msgformato[k]!='\0';k++)
1719   7                    {
1720   8                      vdato(msgformato[k]);
1721   8                    }
1722   7                    
1723   7                      cont(0x80);
1724   7                    for (k=0;lect_cod[k]!='\0';k++)
1725   7                    {
1726   8                      vdato(lect_cod[k]);
1727   8                    }
1728   7                    cont(0x86);             
1729   7                    ve_id('0',buffer_bus[6],buffer_bus[7],buffer_bus[8],buffer_bus[9]);
1730   7                  }
1731   6                  else if ((buffer_bus[3]=='T')&&(buffer_bus[5]!='0'))            // T0:  NO DESARMA !!!!    T:0 CREAR TA
             -RJETAS EN CAJERO
1732   6                  {
1733   7                    Electroiman=0;
1734   7                    cont(0xc0);
1735   7                    for (k=0;offlinea[k]!='\0';k++)
1736   7                    {
1737   8                      vdato(offlinea[k]);
1738   8                    }
1739   7                    cont(0x80);
1740   7                    for (k=0;lect_cod[k]!='\0';k++)
1741   7                    {
1742   8                      vdato(lect_cod[k]);
1743   8                    }
1744   7                    cont(0x86);    // buffer [5] = tipo
1745   7                    ve_id(buffer_bus[5],buffer_bus[6],buffer_bus[7],buffer_bus[8],buffer_bus[9]);
1746   7                  }
1747   6                  else if (buffer_bus[3]=='A')       // ALARMA !!!!
1748   6                  {
1749   7      
1750   7                    cont(0xc0);
1751   7                    for (k=0;err_alarma[k]!='\0';k++)
1752   7                    {
1753   8                      vdato(err_alarma[k]);
1754   8                    }
1755   7                    cont(0xc7);
1756   7                    vdato(buffer_bus[4]);
1757   7                  }
1758   6      
1759   6                  else if ((buffer_bus[3]=='L') ||  (buffer_bus[3]=='Q'))   // LECTURA !!!! modificado jp cmd Q
1760   6                  {
1761   7                    
1762   7                    for (k=0; k<num_data; k++)
1763   7                    {
1764   8                      if (buffer_bus[k]==':')
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 30  

1765   8                      {
1766   9                        Pos_Coma=k;
1767   9                      k=num_data+1;
1768   9                      }
1769   8                    }
1770   7      
1771   7      
1772   7                    cont(0x80);
1773   7                    for (k=0; ingreso[k]!='\0';k++)
1774   7                    {
1775   8                      vdato(ingreso[k]);
1776   8                    }
1777   7                    cont(0x84);
1778   7                    for (k=Pos_Coma+1; k<Pos_Coma+13 ;k++)
1779   7                    {
1780   8                      vdato(buffer_bus[k]);
1781   8                    }
1782   7                    
1783   7                    cont(0xc0);
1784   7                    for (k=0;k<16;k++)
1785   7                    {
1786   8                      vdato(' ');
1787   8                    }
1788   7                  }
1789   6                  else if (buffer_bus[3]=='p')       // LECTURA !!!!
1790   6                  {
1791   7                      cont(0x80);
1792   7                      for (k=0;k<16;k++)
1793   7                      {
1794   8                        vdato(' ');
1795   8                      }
1796   7                      cont(0x80);
1797   7                      for (k=0; k<8;k++)
1798   7                      {
1799   8                        vdato(buffer_bus[4+k]);
1800   8                      }
1801   7                      for (k=0; k<8;k++)
1802   7                      {
1803   8                        vdato(buffer_bus[12+k]);
1804   8                      }
1805   7        
1806   7                      cont(0xc0);
1807   7                      for (k=0;k<16;k++)
1808   7                      {
1809   8                        vdato(' ');
1810   8                      }
1811   7                      cont(0xc0);
1812   7                      for (k=0; k<9;k++)
1813   7                      {
1814   8                        vdato(buffer_bus[21+k]);
1815   8                      }
1816   7      
1817   7      
1818   7                  }
1819   6        
1820   6                  g_cEstadoTxSoft |= LECTURA_COD_TX;
1821   6                  len_buffer=num_data;
1822   6                  for (k=0; k<len_buffer; k++)
1823   6                  {
1824   7                    buffer_ticket[k]=buffer_bus[k];
1825   7      //              tx_chr(buffer_ticket[k]);
1826   7                  }
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 31  

1827   6                  TimeOut_Codigo=cte_seg*3;
1828   6                  retry=0;
1829   6      
1830   6                }
1831   5                if (buffer_bus[3]=='p')
1832   5                {
1833   6                  cont(0x80);
1834   6                  for (k=0;k<16;k++)
1835   6                  {
1836   7                    vdato(' ');
1837   7                  }
1838   6                  cont(0x80);
1839   6                  for (k=0; k<16;k++)
1840   6                  {
1841   7                    vdato(buffer_bus[4+k]);
1842   7                  }
1843   6      
1844   6      
1845   6                  cont(0xc0);
1846   6                  for (k=0;k<16;k++)
1847   6                  {
1848   7                    vdato(' ');
1849   7                  }
1850   6                  cont(0xc0);
1851   6                  for (k=0; k<9;k++)
1852   6                  {
1853   7                    vdato(buffer_bus[21+k]);
1854   7                  }
1855   6      
1856   6                  g_cEstadoTxSoft |= LECTURA_COD_TX;
1857   6                  len_buffer=num_data;
1858   6                  for (k=0; k<len_buffer; k++)
1859   6                  {
1860   7                    buffer_ticket[k]=buffer_bus[k];
1861   7                  }
1862   6                  TimeOut_Codigo=cte_seg*3;
1863   6                  retry=0;
1864   6      
1865   6      
1866   6                }
1867   5                if ((buffer_bus[3]=='?'))
1868   5                {
1869   6                  g_scArrTxComSoft[0]=STX;                    //No hay Novedad 
1870   6                  g_scArrTxComSoft[1]=g_cDirBoard;
1871   6                  g_scArrTxComSoft[2]=0X06;
1872   6                  g_scArrTxComSoft[3]='?';
1873   6                  g_scArrTxComSoft[4]='V';
1874   6                  g_scArrTxComSoft[5]=ETX;
1875   6                  EscribirCadenaSoft(6);
1876   6                  buffer_bus[3]=0xff;
1877   6                }
1878   5                else if ((buffer_bus[3]=='X')&&(buffer_bus[4]==ETX))
1879   5                {
1880   6      
1881   6                  g_cEstadoTxSoft = SIN_LECTURA_TX;
1882   6      
1883   6                  buffer_bus[3]=0x00;
1884   6                  g_cCMD_Soft=SIN_CMD;
1885   6                  FueraServicio=0;
1886   6                  Electroiman=1;
1887   6                    cont(0x80);
1888   6                  for (k=0; k<16 ;k++)
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 32  

1889   6                  {
1890   7                      vdato(' ');
1891   7                  }
1892   6            
1893   6                  cont(0xc0);
1894   6                  for (k=0;linea[k]!='\0';k++)
1895   6                  {
1896   7                      vdato(linea[k]);
1897   7                  }
1898   6      //---------------------------------------------------------------           
1899   6      //            len_buffer=buffer_bus[2];
1900   6      //            for (k=0; k<len_buffer; k++)
1901   6      //            {
1902   6      //              tx_chr(buffer_bus[k]);
1903   6      //            }
1904   6      //---------------------------------------------------------------
1905   6                }
1906   5                else if ((buffer_bus[3]=='S')&&(buffer_bus[5]==ETX))
1907   5                {
1908   6      
1909   6                  if (buffer_bus[4]=='1')
1910   6                  {
1911   7                    g_cEstadoTxSoft |= APERTURA_PUERTA;
1912   7                  }
1913   6                  else if (buffer_bus[4]=='2')
1914   6                  {
1915   7                    g_cEstadoTxSoft |= RETIRO_COFRE_B2B;
1916   7                  }
1917   6                  else if (buffer_bus[4]=='3')
1918   6                  {
1919   7                    g_cEstadoTxSoft |= RETIRO_COFRE_COIN;
1920   7       
1921   7                  }
1922   6      //            buffer_bus[3]=0x00;
1923   6                  buffer_bus[5]=0X00;
1924   6                  g_cCMD_Soft=SIN_CMD;
1925   6        
1926   6                }
1927   5      //          else if ((buffer_bus[3]=='G')&&(buffer_bus[6]==ETX))
1928   5      //          {
1929   5      //
1930   5      //          }
1931   5                else if (buffer_bus[3]=='e')
1932   5                {
1933   6                  
1934   6                  
1935   6      //            g_cEstadoTxSoft |= ERROR_INFO;
1936   6      //            len_buffer=num_data;
1937   6      //            for (k=0; k<len_buffer; k++)
1938   6      //            {
1939   6      //              buffer_ticket[k]=buffer_bus[k];
1940   6      //            }
1941   6      //            TimeOut_Codigo=cte_seg*3;
1942   6      //            retry=0;
1943   6      
1944   6      //            tx_chr(buffer_bus[3]);
1945   6      //            tx_chr(buffer_bus[4]);
1946   6        
1947   6      /*
1948   6      #define SIN_ERROR   0x30    // NO ERROR
1949   6      #define ERR_AUTH    0x31    // ERROR AUTHENTICATION
1950   6      #define ERR_RD      0x32    // NO SE PUDO LEER INFO
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 33  

1951   6      #define ERR_WR      0x33    //
1952   6      #define ERR_EEPROMK   0x34    // ERROR AL GRABAR EN LECTOR
1953   6      #define ERR_LECTOR    0x35    // RESPUESTA INCORRECTA DEL LECTOR
1954   6      #define ERR_EJECT   0x36    // ERROR EN EXPULSAR
1955   6      #define ERR_APB     0x37    // NO POSEE INGRESO
1956   6      #define ERR_COD     0x38    // TARJETA NO ES DE ESTE PARQUEADERO
1957   6      #define DESARM      0x39    // CAJERO DESARMADO / NO PUEDE LIQUIDAR TARJETA DE ROTACION
1958   6      #define ROTACION    0x3A      // TARJETA DE ROTACION
1959   6      #define ERR_CARD_TIPO 0X3B      // ERROR TIPO DE TARJETA (STATUS)
1960   6      #define EXPULSADA   0X3C      // Expulsada Sin Grabacion 
1961   6      #define EXPULSADA_WR  0X3D      // Expulsada con Grabacion
1962   6      #define CARD_EJECT_WR 0X3E      // ERROR TIPO DE TARJETA (STATUS)
1963   6      #define ERR_SELECT    0X3F      // ERROR TIPO DE TARJETA (STATUS) 
1964   6      #define ERR_TARJETA   0X40      // ERROR TARJETA MAL INGRESADA
1965   6      */
1966   6                  switch (buffer_bus[4])
1967   6                  {
1968   7                    case 0x31:
1969   7                      cont(0xC0);
1970   7                      for (k=0; k<16; k++)
1971   7                      {
1972   8                        vdato(err_mifare[k]);
1973   8                      }
1974   7                      cont(0x80);
1975   7                      for (k=0; k<16 ;k++)
1976   7                      {
1977   8                          vdato(' ');
1978   8                      }
1979   7                      Estado_Luz=0x01;
1980   7      
1981   7                    break;
1982   7                      
1983   7                    case 0x33:
1984   7                      cont(0xC0);
1985   7                      for (k=0; k<16; k++)
1986   7                      {
1987   8                        vdato(err_wr[k]);
1988   8                      }
1989   7                      cont(0x80);
1990   7                      for (k=0; k<16 ;k++)
1991   7                      {
1992   8                          vdato(' ');
1993   8                      }
1994   7                      Estado_Luz=0x01;
1995   7                                                        
1996   7                    break;
1997   7      
1998   7      
1999   7                      
2000   7                    case 0x34:
2001   7                      cont(0xC0);
2002   7                      for (k=0; k<16; k++)
2003   7                      {
2004   8                        vdato(err_lect[k]);
2005   8                      }
2006   7                      cont(0x80);
2007   7                      for (k=0; k<16 ;k++)
2008   7                      {
2009   8                          vdato(' ');
2010   8                      }
2011   7                      Estado_Luz=0x01;
2012   7                                                        
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 34  

2013   7                    break;
2014   7      
2015   7                    case 0x37:
2016   7                      cont(0xC0);
2017   7                      for (k=0; k<16; k++)
2018   7                      {
2019   8                        vdato(err_in[k]);
2020   8                      }
2021   7                      cont(0x80);
2022   7                      for (k=0; k<16 ;k++)
2023   7                      {
2024   8                          vdato(' ');
2025   8                      }
2026   7                      Estado_Luz=0x01;
2027   7                                        
2028   7                    break;
2029   7      
2030   7                    case 0x38:
2031   7                      cont(0xC0);
2032   7                      for (k=0; k<16; k++)
2033   7                      {
2034   8                        vdato(err_cod[k]);
2035   8                      }
2036   7                      cont(0x80);
2037   7                      for (k=0; k<16 ;k++)
2038   7                      {
2039   8                          vdato(' ');
2040   8                      }
2041   7                      Estado_Luz=0x01;
2042   7                                        
2043   7                    break;
2044   7      
2045   7                    case 0x39:
2046   7                      cont(0xC0);
2047   7                      for (k=0; k<16; k++)
2048   7                      {
2049   8      //                  vdato(err_uso[k]);
2050   8                      }
2051   7                      cont(0x80);
2052   7                      for (k=0; k<16 ;k++)
2053   7                      {
2054   8                          vdato(' ');
2055   8                      }
2056   7                      
2057   7                                        
2058   7                    break;
2059   7      
2060   7      
2061   7                    case 0x3B:
2062   7                      cont(0xC0);
2063   7      //                for (k=0; k<16; k++)
2064   7      //                {
2065   7      //                  vdato(err_tipo[k]);
2066   7      //                }
2067   7      
2068   7                      vdato('E');
2069   7                      vdato('r');
2070   7                      vdato('r');
2071   7                      vdato('o');
2072   7                      vdato('r');
2073   7                      vdato(' ');
2074   7                      vdato('S');
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 35  

2075   7                      vdato('t');
2076   7                      vdato('a');
2077   7                      vdato('t');
2078   7                      vdato('u');
2079   7                      vdato('s');
2080   7      
2081   7                      cont(0x80);
2082   7                      for (k=0; k<16 ;k++)
2083   7                      {
2084   8                          vdato(' ');
2085   8                      }                 
2086   7                    break;
2087   7      
2088   7                    case 0x3D:
2089   7                      cont(0xc0);
2090   7      //                for (k=0; k<16; k++)
2091   7      //                {
2092   7      //                  vdato(CMD_Out[k]);
2093   7      //                }
2094   7      //                
2095   7                  
2096   7                      vdato('E');
2097   7                      vdato('r');
2098   7                      vdato('r');
2099   7                      vdato('.');
2100   7                      vdato(' ');
2101   7                      
2102   7                      vdato('C');
2103   7                      vdato('a');
2104   7                      vdato('r');
2105   7                      vdato('d');
2106   7                      vdato(' ');
2107   7                      vdato('E');
2108   7                      vdato('j');
2109   7                      vdato('e');
2110   7                      vdato('c');
2111   7                      vdato('t');
2112   7                      vdato(' ');
2113   7      
2114   7                      cont(0x80);
2115   7                      for (k=0; k<16 ;k++)
2116   7                      {
2117   8                          vdato(' ');
2118   8                      } 
2119   7                    break;
2120   7      
2121   7                    case 0x3E:
2122   7                      cont(0xc0);
2123   7                      for (k=0; k<16; k++)
2124   7                      {
2125   8                        vdato(OutWR[k]);
2126   8                      }
2127   7                      cont(0x80);
2128   7                      for (k=0; k<16 ;k++)
2129   7                      {
2130   8                          vdato(' ');
2131   8                      } 
2132   7                    break;
2133   7      
2134   7                    case 0x3F:
2135   7                      cont(0xc0);
2136   7                      for (k=0; k<16; k++)
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 36  

2137   7                      {
2138   8                        vdato(OutSEL[k]);
2139   8                      }
2140   7                      cont(0x80);
2141   7                      for (k=0; k<16 ;k++)
2142   7                      {
2143   8                          vdato(' ');
2144   8                      } 
2145   7                    break;
2146   7      
2147   7      
2148   7                    case 0x40:
2149   7      
2150   7                      Estado_Luz=0x01;
2151   7      //                g_scArrTxComSoft[0]=STX;
2152   7      //                g_scArrTxComSoft[1]='0';
2153   7      //                  g_scArrTxComSoft[2]=0X06;
2154   7      //                g_scArrTxComSoft[3]='?';
2155   7      //                g_scArrTxComSoft[4]='F';
2156   7      //                  g_scArrTxComSoft[5]=ETX;
2157   7      //                EscribirCadenaSoft(6);
2158   7      //                g_cEstadoComSoft=ESPERA_RX;
2159   7      //                g_cCMD_Soft=SIN_CMD;
2160   7      
2161   7                      g_cEstadoTxSoft |= ERROR_WR_CARD;
2162   7                      buffer_bus[3]=0xff;
2163   7                        g_cCMD_Soft=SIN_CMD;
2164   7      
2165   7      
2166   7                      cont(0xc0);
2167   7      //                for (k=0; k<16; k++)
2168   7      //                {
2169   7      //                  vdato(err_Tarjeta[k]);
2170   7      //                }
2171   7                      vdato('E');
2172   7                      vdato('r');
2173   7                      vdato('r');
2174   7                      vdato('o');
2175   7                      vdato('r');
2176   7                      vdato(' ');
2177   7                      vdato('C');
2178   7                      vdato('A');
2179   7                      vdato('R');
2180   7                      vdato('D');
2181   7      
2182   7                      cont(0x80);
2183   7                      for (k=0; k<16 ;k++)
2184   7                      {
2185   8                          vdato(' ');
2186   8                      } 
2187   7                    break;
2188   7      
2189   7                    case 0x41:
2190   7      
2191   7      
2192   7                      g_cEstadoTxSoft &=~LECTURA_COD_TX;
2193   7                      g_cEstadoComSoft=ESPERA_RX; 
2194   7                      g_cCMD_Soft=SIN_CMD;
2195   7      
2196   7      
2197   7                      Estado_Luz=0x01;
2198   7      
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 37  

2199   7                      buffer_bus[3]=0xff;
2200   7                        g_cCMD_Soft=SIN_CMD;
2201   7      
2202   7      
2203   7                      cont(0xc0);
2204   7                      for (k=0; k<16; k++)
2205   7                      {
2206   8      //                  vdato(err_TIME[k]);
2207   8                      }
2208   7                      cont(0x80);
2209   7                      for (k=0; k<16 ;k++)
2210   7                      {
2211   8                          vdato(' ');
2212   8                      } 
2213   7                    break;
2214   7       
2215   7                  }
2216   6                  
2217   6                }
2218   5      
2219   5              }
2220   4              num_data=0;
2221   4            }
2222   3            buffer_bus[0]=0x00;
2223   3          }       
2224   2      //------------------------------------------------------------------------------------------*
2225   2      //    FIN ATENCION INT
2226   2      //------------------------------------------------------------------------------------------*
2227   2          if (txACK==1)
2228   2          {
2229   3            g_scArrTxComSoft[0]=STX;                    //No hay Novedad 
2230   3            g_scArrTxComSoft[1]=g_cDirBoard;
2231   3            g_scArrTxComSoft[2]=0X05;
2232   3            g_scArrTxComSoft[3]=ACK;
2233   3            g_scArrTxComSoft[4]=ETX;
2234   3            EscribirCadenaSoft(5);
2235   3            g_cEstadoComSoft=ESPERA_RX;
2236   3            g_cCMD_Soft=SIN_CMD;
2237   3            g_cEstadoTxSoft=SIN_LECTURA_TX;
2238   3            txACK=0;    
2239   3          }
2240   2      //------------------------------------------------------------------------------------------*
2241   2      //    TIMERS
2242   2      //------------------------------------------------------------------------------------------*
2243   2          if (TF2==1)
2244   2          {
2245   3            TF2=0;
2246   3            if (seg2!=0)
2247   3            {
2248   4              seg2--;
2249   4              if (seg2==0)
2250   4              {
2251   5                seg2=cte_seg;
2252   5      
2253   5      
2254   5              }
2255   4            }
2256   3          }
2257   2      //--------------------------------------------------------------------------------------------------------
             ---*
2258   2      
2259   2      //**********************************************************************************************
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 38  

2260   2          if(TF0==1)
2261   2          {
2262   3            TF0=0;
2263   3            seg--;
2264   3      //----------------------------------------------------------------------------------------------*
2265   3            if (SignalAcceso==0)
2266   3            {
2267   4              if ((seg==cte_seg/2)||(seg==0))
2268   4              {
2269   5                if (toogle==1)
2270   5                {
2271   6                  ledv=0;
2272   6                  toogle=0;
2273   6                }
2274   5                else
2275   5                {
2276   6                  ledv=1;
2277   6                  toogle=1;
2278   6                }
2279   5              }
2280   4            }
2281   3            else
2282   3            {
2283   4              ledv=1;
2284   4            }
2285   3      //----------------------------------------------------------------------------------------------*
2286   3            if ((seg==cte_seg/2)||(seg==0))
2287   3            {
2288   4              if (Estado_Luz==0x01)
2289   4              {
2290   5                audio1=~audio1;
2291   5                audio2=0;
2292   5                audio3=0;
2293   5                audio4=0;
2294   5              }
2295   4              else if (Estado_Luz==0x02)
2296   4              {
2297   5                audio1=0;
2298   5                audio2=~audio2;
2299   5                audio3=0;
2300   5                audio4=0;
2301   5      
2302   5              }
2303   4              else if (Estado_Luz==0x03)
2304   4              {
2305   5                audio1=0;
2306   5                audio2=0;
2307   5                audio3=~audio3;
2308   5                audio4=0;
2309   5      
2310   5              }
2311   4            }
2312   3      //----------------------------------------------------------------------------------------------*
2313   3            if (seg==0x00)
2314   3            {
2315   4              seg=cte_seg;        //Base de segundo con eltimer 0x1c = 28       *
2316   4              if (TimeOutLinea!=0)
2317   4              {
2318   5                TimeOutLinea--;
2319   5        
2320   5              }
2321   4              if (Time_Devolucion!=0)
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 39  

2322   4              {
2323   5                  Time_Devolucion--;
2324   5                if (Time_Devolucion==0)
2325   5                {
2326   6                  Estado_Luz=0x01;
2327   6                }
2328   5      
2329   5              }
2330   4              
2331   4              if (TimeOutLinea==0)
2332   4              {
2333   5        
2334   5                TimeOutLinea=TIMEW;
2335   5                cont(0x80);
2336   5                for (k=0;k<16;k++)
2337   5                {
2338   6                    vdato(' ');
2339   6                }
2340   5        
2341   5                  FueraLinea=1;
2342   5        
2343   5              }
2344   4      
2345   4       
2346   4      
2347   4      
2348   4              lock1=0;
2349   4              lock2=0;
2350   4              flag_segundo=0;
2351   4              seg=cte_seg;
2352   4              TH0=0X00;               //Inicializa timer                    *           
2353   4              TL0=0X00;
2354   4      
2355   4      
2356   4            }
2357   3            if (TimeOut_Codigo!=0)
2358   3            {
2359   4              TimeOut_Codigo--;
2360   4              if (TimeOut_Codigo==0x0001)
2361   4              {
2362   5      //---------------------------------------------------------
2363   5      //          g_cEstadoTxSoft &=~LECTURA_COD_TX;
2364   5      //          buffer_wie[0]=0x00;
2365   5      //          buffer_wie[1]=0x00;
2366   5      //          buffer_wie[2]=0x00;
2367   5      //          buffer_wie[3]=0x00;
2368   5      //          nbitsW=0;
2369   5      //----------------------------------------------------------
2370   5              }
2371   4            }
2372   3            else
2373   3            {
2374   4              retry=0;        
2375   4            }
2376   3          }
2377   2      //----------------------------------------------------------------------------------------------*
2378   2          relevos_aux();
2379   2      //----------------------------------------------------------------------------------------------*
2380   2         }                        //Cierra While Principal          * 
2381   1      }                         //Cierra main               *
2382          //***********************************************************************************************
2383          
C51 COMPILER V9.59.0.0   PRINCIPAL_MF                                                      03/02/2020 12:29:49 PAGE 40  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8710    ----
   CONSTANT SIZE    =     87    ----
   XDATA SIZE       =    580     151
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     17       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
